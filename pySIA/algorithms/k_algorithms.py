# -*- coding: utf-8 -*-
"""
Created on Tue May 17 12:41:21 2016

@author: phil

Methods that use keras extensively
Using python 3.5
"""

import keras
import theano
import os
from utils import k_utils
os.environ["THEANO_FLAGS"] = "mode=FAST_RUN,device=gpu,floatX=float32"



from utils.k_utils import SIAValidate

theano.config.exception_verbosity='high'

from models import k_defaultOptions

def importantOptions(given_options):
    '''important options for the SIA methods, these must be given '''
    options = dict()

    ### These must be stored ###
    
    #Input Shape can be generated by using the model's _getInputShape method
    options['Input_Shape']= given_options['Input_Shape'] 
    
    #Frames information must be given before any model can be generated
    options['Frames'] = given_options['Frames']
    
    
    return options
def k_SIAAdam(model_class,X_train,y_train,X_valid,y_valid,X_test,y_test,given_options=dict()):
    ''' X_vectors should be (nb_samples, nb_image_frames (or other third dimension), nb_rows,nb_columns) '''   
    methodName = model_class.model_name
    print(methodName)


    options = importantOptions(given_options)
    ####################
    #DEFAULT PARAMETERS#
    ####################
    options.update(k_defaultOptions.adamDefaults(given_options))
    options.update(model_class.defaultOptions(given_options))
    
    
    k_utils.printDictionary(options,'options')

    #Build Model
    model = model_class.buildModel(options)    
    optimizerFunction = keras.optimizers.Adam(lr=options['Learning_Rate'])
    model.compile(loss=options['Loss_Function'], optimizer=optimizerFunction)    
    earlyStop=keras.callbacks.EarlyStopping(monitor='val_loss', patience=options['Patience'], verbose=0, mode='auto')
    
    #Fit Model
    model.fit(X_train,y_train, validation_data=(X_valid,y_valid), nb_epoch = options['N_Epochs'],
              batch_size=options['Batch_Size'],callbacks=[ earlyStop],verbose=2)

    #Validate Model   
    results,estimatedModel = SIAValidate(
    model,X_train,y_train,X_valid,y_valid,X_test,y_test)


    bestModel = results
    bestModel['options'] = options
    bestModel['model'] = estimatedModel
    bestModel['method'] = methodName
    bestModel['model_class'] = model_class
    
    k_utils.printDictionary(options,'options')
#    print('\n Printing some estimated model parameters...')
#    print("{} = {}".format('p_opt', str(estimatedModel['p_opt'])))
#    print("{} = {}".format('alpha', str(estimatedModel['weights'][2])))
    
    
    return bestModel
def k_SIAOptimizer(model_class,X_train,y_train,X_valid,y_valid,X_test,y_test,given_options=dict()):
    ''' X_vectors should be (nb_samples, nb_image_frames (or other third dimension), nb_rows,nb_columns) '''
    methodName = model_class.model_name
    print(methodName)


    options = importantOptions(given_options)
    ####################
    #DEFAULT PARAMETERS#
    ####################
    options.update(k_defaultOptions.adamDefaults(given_options))
    options.update(model_class.defaultOptions(given_options))


    k_utils.printDictionary(options,'options')

    #Build Model
    model = model_class.buildModel(options)
   
    if options['Optimizer'] == 'Adam':
        optimizerFunction = keras.optimizers.Adam()
    elif options['Optimizer'] == 'RMSprop':
        optimizerFunction = keras.optimizers.RMSprop(lr=options['Learning_Rate']) 
    elif options['Optimizer'] == 'Adagrad':
        optimizerFunction = keras.optimizers.Adagrad()
    elif options['Optimizer'] == 'Adadelta':
        optimizerFunction = keras.optimizers.Adadelta() 
    elif options['Optimizer'] == 'Nadam':
        optimizerFunction = keras.optimizers.Nadam() 
    elif options['Optimizer'] == 'Adamax':
        optimizerFunction = keras.optimizers.Adamax()

    model.compile(loss=options['Loss_Function'], optimizer=optimizerFunction)
    earlyStop=keras.callbacks.EarlyStopping(monitor='val_loss', patience=options['Patience'], verbose=0, mode='auto')

    #Fit Model
    model.fit(X_train,y_train, validation_data=(X_valid,y_valid), nb_epoch = options['N_Epochs'],
              batch_size=options['Batch_Size'],callbacks=[ earlyStop],verbose=2)

    #Validate Model
    results,estimatedModel = SIAValidate(
    model,X_train,y_train,X_valid,y_valid,X_test,y_test)


    bestModel = results
    bestModel['options'] = options
    bestModel['model'] = estimatedModel
    bestModel['method'] = methodName
    bestModel['model_class'] = model_class

    k_utils.printDictionary(options,'options')
#    print('\n Printing some estimated model parameters...')
#    print("{} = {}".format('p_opt', str(estimatedModel['p_opt'])))
#    print("{} = {}".format('alpha', str(estimatedModel['weights'][2])))


    return bestModel
    

def k_SIASGD(model_class,X_train,y_train,X_valid,y_valid,X_test,y_test,given_options):
    ''' X_vectors should be (nb_samples, nb_Features) '''
    methodName = model_class.model_name
    print(methodName)
    
    options = importantOptions(given_options)

    ####################
    #DEFAULT PARAMETERS#
    ####################
    options.update(k_defaultOptions.sgdDefaults(given_options))
    options.update(model_class.defaultOptions(given_options))
    
    
    k_utils.printDictionary(options,'options')

    model = model_class.buildModel(options)         
    #note: the Adam optimizer doesn't seem to work well here, so we use SGD
    optimizerFunction = keras.optimizers.SGD(lr=options['Learning_Rate'],
                                             decay=options['Decay'],
                                             momentum=options['Momentum'],
                                             nesterov=True,
                                             clipnorm = options['ClipNorm'],
                                             clipvalue= options['ClipValue'])
    
    model.compile(loss=options['Loss_Function'], optimizer=optimizerFunction)
    earlyStop=keras.callbacks.EarlyStopping(monitor='val_loss', patience=options['Patience'], verbose=0, mode='auto')
    #Fit Model
    model.fit(X_train,y_train, validation_data=(X_valid,y_valid), nb_epoch = options['N_Epochs'],
              batch_size=options['Batch_Size'],callbacks=[ earlyStop],verbose=2)
    
    #Validate Model
    results,estimatedModel = SIAValidate(
    model,X_train,y_train,X_valid,y_valid,X_test,y_test)

    bestModel = results
    bestModel['options'] = options
    bestModel['model'] = estimatedModel
    bestModel['method'] = methodName
    bestModel['model_class'] = model_class
#    k_utils.printDictionary(options,'options')
#    print('\n Printing some estimated model parameters...')
#    print("{} = {}".format('p_opt', str(estimatedModel['p_opt'])))
        
    return bestModel
    

    
